Plan de implementación por etapas (librerías estáticas Linux)
===========================================================
Objetivo: habilitar en el binario estático de Linux las librerías actualmente omitidas. Ordenadas de menor a mayor complejidad de enlazado.

Etapa 0 — Preparativos
- Reusar PREFIX=/build/dist/linux y PKG_CONFIG_PATH con $PREFIX/lib/pkgconfig:$PREFIX/lib64/pkgconfig.
- Añadir helper genérico build_from_source(name, url, flags) si hace falta; respetar --static y --disable-shared.
- Limpiar/actualizar shims .pc cuando se instalen librerías nuevas.

Etapa 1 — Pila de texto/subtítulos (dependencias encadenadas, pero relativamente sencillas)
1. freetype (dep: zlib, libpng, opcional brotli) → build estático en $PREFIX con pkg-config correcto.
2. fribidi → build estático simple, instala .pc.
3. harfbuzz (dep: freetype, fribidi, icu opcional; compilar sin icu para simplificar) → build estático, --with-freetype --with-fribidi, generar .pc con Libs privadas completas.
4. libass (dep: freetype, fribidi, harfbuzz, fontconfig opcional) → build estático apuntando a $PREFIX, revisar Libs/Libs.private en .pc.
Resultado esperado: --enable-libharfbuzz y --enable-libass se habilitan.

Etapa 2 — Codecs adicionales
1. dav1d → build estático con meson/ninja (-Ddefault_library=static), instala .pc con Libs: -lm -lpthread si hiciera falta.
2. x265 → build estático (multilib single-bitdepth para simplicidad), exporta .pc y libx265.a.
3. soxr → build estático con cmake (-DBUILD_SHARED_LIBS=OFF), .pc mínimo si no lo instala.
Resultado: --enable-libdav1d, --enable-libx265, --enable-libsoxr.

Etapa 3 — Utilidades de parsing/crypto de red
1. libxml2 → build estático (./configure --enable-static --disable-shared --without-python), .pc en $PREFIX.
2. libssh → build estático contra openssl y krb5; si el .pc resultante no arrastra GSSAPI, parchear Libs para incluir -lgssapi_krb5 -lkrb5 -lk5crypto -lcom_err -lkrb5support -lresolv -lssl -lcrypto.
Resultado: --enable-libxml2 y --enable-libssh habilitados sin fallos GSSAPI.

Etapa 4 — Stacks de aceleración y media (complejidad alta, opcional si se requiere 100% estático)
- libvpl: intentar build estático del SDK oneVPL; si no provee libvpl.a usable, mantener WARN.
- vaapi: solo habilitar si se consigue libva.a estática; de lo contrario, dejar WARN.
- opencl: requiere loader estático (pocl/ocl-icd no suelen proveer .a); si no hay ruta segura, mantener WARN.
- vulkan: intentar build de loader estático (Vulkan-Loader) contra headers 1.3.277+; si falla o arrastra .so, dejar WARN.

Etapa 5 — Verificación y export
- Reejecutar docker compose run --rm ffmpeg-builder linux > logs/linux.log 2>&1.
- Validar: file output/.../linux/ffmpeg → “statically linked”.
- Validar flags: ffmpeg -buildconf contiene libass/libharfbuzz/libdav1d/libsoxr/libx265/libxml2/libssh.
- Mantener WARN solo para stacks que no puedan ser 100% estáticos (opencl/vaapi/vulkan/libvpl) con justificación en el log.
